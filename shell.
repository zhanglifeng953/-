一：
shell: bash sch sh ksh
快捷键  历史记录 别名（颜色） 重定向 管道
脚本组成：解释器 注释 代码
脚本打开方式：+x权限 bash source . ./ 
变量：自定义变量 
环境变量：$USER $PID $PWD $HOSTNAME $PATH 
位置变量 : $1 $2 $10 ... 
预定义变量: $0 $? $# $* $$
1）双引号的应用
使用双引号可以界定一个完整字符串。
2）单引号的应用
界定一个完整的字符串，并且可以实现屏蔽特殊符号的功能。
3）反撇号或$()的应用
使用反撇号或$()时，可以将命令执行的标准输出作为字符串存储，因此称为命令替换。

二：
案例1：Shell中的数值运算
案例2：条件测试操作
案例3：使用if选择结构

步骤一：整数运算工具
1）使用expr命令
乘法操作应采用 \* 转义，避免被作为Shell通配符；参与运算的整数值与运算操作符之间需要以空格分开，引用变量时必须加$符号。
首先定义变量X=1234，然后分别计算与78的加减乘除和求模运算结果：

[root@svr5 ~]# X=1234                              //定义变量X
[root@svr5 ~]# expr  $X  +  78                      //加法
1312
[root@svr5 ~]# expr  $X  -  78                       //减法
1156
[root@svr5 ~]# expr  $X  \*  78                      //乘法，操作符应添加\转义
96252
[root@svr5 ~]# expr  $X  /  78                      //除法，仅保留整除结果
15
[root@svr5 ~]# expr  $X  %  78                     //求模
64

2）使用$[]或$(())表达式
乘法操作*无需转义，运算符两侧可以无空格；引用变量可省略 $ 符号；计算结果替换表达式本身，可结合echo命令输出。
同样对于变量X=1234，分别计算与78的加减乘除和求模运算结果：

[root@svr5 ~]# X=1234   
[root@svr5 ~]# echo $[X+78]
1312
[root@svr5 ~]# echo $[X-78]
1156
[root@svr5 ~]# echo $[X*78]
96252
[root@svr5 ~]# echo $[X/78]
15
[root@svr5 ~]# echo $[X%78]
64

3）使用let命令
expr或$[]、$(())方式只进行运算，并不会改变变量的值；而let命令可以直接对变量值做运算再保存新的值。因此变量X=1234，在执行let运算后的值会变更；另外，let运算操作并不显示结果，但是可以结合echo命令来查看：
[root@svr5 ~]# X=1234  
[root@svr5 ~]# let y=X+22
[root@svr5 ~]# echo $y
1256
[root@svr5 ~]# let X++;  echo $X        # X++(X=X+1)
[root@svr5 ~]# let X--;  echo $X        # X--(X=X-1)
[root@svr5 ~]# let X+=78 ; echo $X        # X+=78(X=X+78)
[root@svr5 ~]# let X-=78 ; echo $X     # X-=78(X=X-78)
[root@svr5 ~]# let X*=78 ; echo $X     # X*=78(X=X*78)
[root@svr5 ~]# let X/=78 ; echo $X     # X/=78(X=X/78)
[root@svr5 ~]# let X%=78 ; echo $X     # X%=78(X=X%78)

步骤二：小数运算工具

1）bc交互式运算
先执行bc命令进入交互环境，然后再输入需要计算的表达式。以计算小数12.34与5.678的四则运算为例，相关操作如下：

[root@svr5 ~]# bc 
bc 1.06.95
Copyright 1991-1994, 1997, 1998, 2000, 2004, 2006 Free Software Foundation, Inc.
This is free software with ABSOLUTELY NO WARRANTY.
For details type `warranty'. 
12.34+56.78                                        //加法
69.12
12.34-56.78                                        //减法
-44.44
12.34*56.78                                        //乘法
700.66
12.34/56.78                                        //除法
0
quit                                              //退出交互计算器
[root@svr5 ~]#


2）bc非交互式运算
将需要运算的表达式通过管道操作交给bc运算。注意，小数位的长度可采用scale=N限制，除此以外也受参与运算的数值的小数位影响。以计算小数12.34与5.678的四则运算为例，相关操作如下：

[root@server0 ~]# echo '10*10' | bc
100
[root@svr5 ~]# echo 'scale=4;12.34+5.678' | bc
18.018
[root@svr5 ~]# echo 'scale=4;12.34*5.678' | bc 
70.0665
[root@svr5 ~]# echo 'scale=4;12.34/5.678' | bc 
2.1733

2.2 步骤

实现此案例需要按照如下步骤进行。
步骤一：条件测试的基本用法

1）语法格式
使用“test 表达式”或者[ 表达式 ]都可以，表达式两边至少要留一个空格。
条件测试操作本身不显示出任何信息。测试的条件是否成立主要体现在命令执行后的返回状态（即 $?），所以可以在测试后查看变量$?的值来做出判断，或者结合&&、||等逻辑操作显示出结果（或作其他操作） 。
步骤二：字符串测试

1）== 比较两个字符串是否相同
检查当前用户是否为root。

当root用户执行时：
[root@svr5 ~]# [ $USER == "root" ]         //测试
[root@svr5 ~]# echo $?                    //查看结果0为对，非0为错

当普通用户执行时：
[zengye@svr5 ~]$ [ $USER == "root" ]
[zengye@svr5 ~]$ echo $?                    //查看结果0为对，非0为错

2）!= 比较两个字符串是否不相同

当普通用户执行时：
[zengye@svr5 ~]$ [ $USER != "root" ] 

当root用户执行时：
[root@svr5 ~]# [ $USER != "root" ]


3）一行执行多条命令的情况
# A && B                        //仅当A命令执行成功，才执行B命令
# A || B                        //仅当A命令执行失败，才执行B命令
# A ;  B                        //执行A命令后执行B命令，两者没有逻辑关系
# A && B || C                   //思考？


-eq 等于 
-ne 不等于
-gt 大于
-lt 小于
-ge 大于等于
-le 小于等于

步骤四：识别文件/目录的状态

1）-e 判断对象是否存在（不管是目录还是文件）
2）-d 判断对象是否为目录（存在且是目录）
3）-f 判断对象是否为文件（存在且是文件）
4）-r 判断对象是否可读
5）-w 判断对象是否可写
6）-x 判断对象是否具有可执行权限
例：
[ -x  "/root/2" ] && echo "是" || echo "否"

步骤五：多个条件/操作的逻辑组合

1）&&，逻辑与
给定条件必须都成立，整个测试结果才为真。
检查变量X的值是否大于10，且小于30：
[root@svr5 ~]# X=20                      //设置X变量的值为20
[root@svr5 ~]# [ $X -gt 10 ] && [ $X -lt 30 ] && echo "YES"
YES

2）||，逻辑或
只要其中一个条件成立，则整个测试结果为真。
只要/tmp/、/var/spool/目录中有一个可写，则条件成立：
[root@svr5 ~]# [ -w "/tmp/" ] || [ -w "/var/spool/" ] && echo "OK"
OK

3 案例3：使用if选择结构
3.1 问题

本案例要求编写3个Shell脚本，分别实现以下目标：
检测/media/cdrom目录，若不存在则创建
检测并判断指定的主机是否可ping通
从键盘读取一个论坛积分，判断论坛用户等级，等级分类如下:
大于等于90	神功绝世
大于等于80，小于90	登峰造极
大于等于70，小于80	炉火纯青
大于等于60，小于70	略有小成
小于60	初学乍练
3.2 方案

if单分支的语法组成：
if  条件测试
then  
命令序列
fi
if双分支的语法组成：
if  条件测试
then
命令序列1
else  
命令序列2
fi
if多分支的语法组成：
if    条件测试1 ;then  
命令序列1
elif  条件测试2 ;then  
命令序列2
else
命令序列n
fi
3.3 步骤

实现此案例需要按照如下步骤进行。
步骤一：检测/media/cdrom目录，若不存在则创建

1）编写脚本如下：
[root@svr5 ~]# vim mountdir.sh 
#!/bin/bash
dir="/media/cdrom/"            
if [ ! -d $dir ]         //！代表不存在为真
then
    mkdir -p $dir
fi 
[root@svr5 ~]# chmod +x mountdir.sh                  //添加可执行权限
2）测试、验证脚本功能
[root@svr5 ~]# ls -ld /media/cdrom                  //本来没有/media/cdrom目录
ls: /media/cdrom: 没有那个文件或目录
[root@svr5 ~]# ./mountdir.sh                          //执行脚本
[root@svr5 ~]# ls -ld /media/cdrom                  //再检查已经有了
drwxr-xr-x 2 root root 4096 12-11 15:16 /media/cdrom
有了/media/cdrom文件夹以后，再次执行上述脚本，实际上不做任何有效操作：
[root@svr5 ~]# ./mountdir.sh

字符判断：[ abc == xyz ]    !=  -z ! -z
数字判断：-eq -ne -ge -gt -le -lt 
文字判断：-e -f -d -r -w -x 
判断&&命令   判断成功

三,
 案例1：使用for循环结构

1.2 方案

在Shell脚本应用中，常见的for循环采用遍历式、列表式的执行流程，通过指定变量从值列表中循环赋值，每次复制后执行固定的一组操作。
for循环的语法结构如下所示：
for  变量名  in  值列表
do
    命令序列
done
for  变量名  in  {1..5}
do
    命令序列
done
for  变量名  in  `seq 5`
do
    命令序列
done
for  变量名  in  `ls /etc/*.conf`
do
    命令序列
done
1.3 步骤

实现此案例需要按照如下步骤进行。
步骤一：练习for循环基本用法

脚本1，通过循环批量显示5个hello world：
[root@svr5 ~]# vim for01.sh
#!/bin/bash
for i in 1 2 3 4 5
do
        echo "hello world"
done
[root@svr5 ~]# chmod +x for01.sh
[root@svr5 ~]# ./for01.sh
脚本2，通过循环批量显示10个hello world：
[root@svr5 ~]# vim for02.sh
#!/bin/bash
for i in {1..10}
do
        echo "hello world"
done
[root@svr5 ~]# chmod +x for02.sh
[root@svr5 ~]# ./for02.sh
脚本3，通过循环批量显示10个数字：
[root@svr5 ~]# vim for03.sh
#!/bin/bash
for i in {1..10}
do
        echo "$i"
done
[root@svr5 ~]# chmod +x for03.sh
[root@svr5 ~]# ./for03.sh


1）编写脚本如下：
命令备注：ping命令可以测试某台主机的连通性，
使用-c选项可以设置ping的次数，
使用-i选项可以设置多次ping之间的间隔时间（单位秒），
使用-W选项可以设置ping不通时的超时时间（单位秒）。
[root@svr5 ~]# vim chkhosts.sh
#!/bin/bash
for i in {1..254}
do
    ping -c 3 -i 0.2 -W 1 192.168.4.$i &> /dev/null
    if [ $? -eq 0 ] ; then
        echo "Host 192.168.4.$i is up."
    else
        echo "Host 192.168.4.$i is down."
    fi
done
[root@svr5 ~]# chmod +x chkhosts.sh
4）测试、验证脚本
… …
[root@svr5 ~]# ./chkhosts.sh
Host 192.168.4.5 is up.
Host 192.168.4.6 is down
… …
步骤三：创建账户的案例

创建users.txt，写入无规律的账户名称，最后使用for循环读取该文件，批量创建账户并设置密码。
[root@svr5 ~]# vim addfor.sh
#!/bin/bash
for i in `cat /root/user.txt`
do
     useradd $i
     echo 123456 | passwd --stdin $i
done
附加扩展知识（C语言风格的for循环语法格式）
[root@svr5 ~]# vim cfor.sh
#!/bin/bash
for ((i=1;i<=5;i++))
do
   echo $i
done



2 案例2：使用while循环结构  

2.1 问题

本案例要求编写2个使用while循环的脚本程序，分别实现以下目标：
提示用户猜测一个随机数，直到才对为止
检测192.168.4.0/24网段，列出不在线的主机地址
2.2 方案

while循环属于条件式的执行流程，会反复判断指定的测试条件，只要条件成立即执行固定的一组操作，直到条件变化为不成立为止。所以while循环的条件一般通过变量来进行控制，在循环体内对变量值做相应改变，以便在适当的时候退出，避免陷入死循环。
while循环的语法结构如下所示：
while  条件测试
do
    命令序列
done
while :
do
    命令序列
done
2.3 步骤

实现此案例需要按照如下步骤进行。
步骤一：练习while循环基本用法

脚本1，无心的死循环脚本：
[root@svr5 ~]# vim while01.sh
#!/bin/bash
i=1
while [ $i -le 5 ]
do
        echo "$i"
done
[root@svr5 ~]# chmod +x while01.sh
[root@svr5 ~]# ./while01.sh                //死循环，需要使用Ctrl+C终止脚本
脚本2，有效循环脚本：
[root@svr5 ~]# vim while02.sh
#!/bin/bash
i=1
while [ $i -le 5 ]
do
        echo "$i"
        let i++
done
[root@svr5 ~]# chmod +x while02.sh
[root@svr5 ~]# ./while02.sh
脚本3，死循环的一般格式：
[root@svr5 ~]# vim while03.sh
#!/bin/bash
while :
do
        echo "hello world"
done
[root@svr5 ~]# chmod +x while03.sh
[root@svr5 ~]# ./while03.sh                //死循环，需要使用Ctrl+C终止脚本


3 案例3：基于case分支编写脚本
3.1 问题

本案例要求编写test.sh脚本，相关要求如下：
能使用redhat、fedora控制参数
控制参数通过位置变量$1传入
当用户输入redhat参数，脚本返回fedora
当用户输入fedora参数，脚本返回redhat
当用户输入其他参数，则提示错误信息
3.2 方案

case分支属于匹配执行的方式，它针对指定的变量预先设置一个可能的取值，判断该变量的实际取值是否与预设的某一个值相匹配，如果匹配上了，就执行相应的一组操作，如果没有任何值能够匹配，就执行预先设置的默认操作。
case分支的语法结构如下所示：
case  变量  in
模式1)
    命令序列1 ;;
模式2)
    命令序列2 ;;
    .. ..
*)
    默认命令序列
esac



4 案例4：使用Shell函数
4.1 问题

本案例要求编写脚本mycolor.sh，相关要求如下：
将颜色输出的功能定义为函数
调用函数，可以自定义输出内容和颜色
4.2 方案

在Shell脚本中，将一些需重复使用的操作，定义为公共的语句块，即可称为函数。通过使用函数，可以使脚本代码更加简洁，增强易读性，提高Shell脚本的执行效率
1）函数的定义方法
格式1：
function  函数名 {
    命令序列
    .. ..
}

格式2：
函数名() {
    命令序列
    .. ..
}


2）函数的调用
直接使用“函数名”的形式调用，如果该函数能够处理位置参数，则可以使用“函数名 参数1 参数2 .. ..”的形式调用。
注意：函数的定义语句必须出现在调用之前，否则无法执行。
3) 测试语法格式
[root@svr5 ~]# mycd(){                        //定义函数
> mkdir /test
> cd /test
> }
[root@svr5 ~]# mycd                            //调用函数
[root@svr5 ~]# mycd(){                        //定义函数
> mkdir $1
> cd $1
> }
[root@svr5 ~]# mycd  /abc                            //调用函数
[root@svr5 ~]# mycd  /360                            //调用函数
4.3 步骤

实现此案例需要按照如下步骤进行。
步骤一：编写mycolor.sh脚本

1）任务需求及思路分析
用户在执行时提供2个整数参数，这个可以通过位置变量$1、$2读入。
调用函数时，将用户提供的两个参数传递给函数处理。
颜色输出的命令:echo -e "\033[32mOK\033[0m"。
3X为字体颜色，4X为背景颜色。
2）根据实现思路编写脚本文件
[root@svr5 ~]# vim mycolor.sh
#!/bin/bash
cecho() {
    echo -e "\033[$1m$2\033[0m"
}
cecho 32 OK
cecho 33 OK
cecho 34 OK
cecho 35 OK
[root@svr5 ~]# chmod +x mycolor.sh
3）测试脚本执行效果
[root@svr5 ~]# ./mycolor.sh
使用函数，优化改进前面的脚本：
[root@svr5 ~]# vim myping.sh
#!/bin/bash
myping(){
    ping -c1 -W1  $1  &>/dev/null
    if [ $? -eq 0 ];then
        echo "$1 is up"
    else
        echo "$1 is down"
    fi
}
for  i  in  {1..254}
do
     myping  192.168.4.$i  &
done
wait
#wait命令的作用是等待所有后台进程都结束才结束脚本。
Shell版本的fork炸弹
[root@svr5 ~]# vim test.sh
#!/bin/bash
.(){
.|.&
}
.


break 可以结束整个循环；
continue 结束本次循环，进入下一次循环；
exit 结束整个脚本。



5 案例5：中断及退出
5.1 问题

本案例要求编写两个Shell脚本，相关要求如下：
从键盘循环取整数（0结束）并求和，输出最终结果
找出1~20以内6的倍数，并输出她的平方值
5.2 方案

通过break、continue、exit在Shell脚本中实现中断与退出的功能。
break可以结束整个循环；continue结束本次循环，进入下一次循环；exit结束整个脚本，案例如下：
[root@svr5 ~]# vim  test.sh
#!/bin/bash
for  i   in   {1..5}
do
       [  $i  -eq  3 ]&& break //这里将break替换为continue，exit分别测试脚本执行效果       echo $i
done
echo "Game Over"
5.3 步骤

实现此案例需要按照如下步骤进行。
步骤一：编写求和脚本sum.sh

1）编写脚本文件
[root@svr5 ~]# vim sum.sh 
#!/bin/bash
SUM=0
while :
do 
read  -p  "请输入整数（0表示结束）："  x
    [ $x -eq 0 ]  &&  break
    SUM=$[SUM+x]
done
echo "总和是：$SUM"
[root@svr5 ~]# chmod +x sum.sh
[root@svr5 ~]# ./sum.sh
步骤二：编写脚本文件，找出1-20内6的倍数，并打印她的平方值

1）编写脚本文件
注意：要求打印所有6的倍数的平方值，也就是非6的倍数都跳过！！！
[root@svr5 ~]# vim test.sh 
#!/bin/bash
for i in {1..20}
do
    [ $[i%6] -ne 0 ]  &&  continue
    echo $[i*i]
done
[root@svr5 ~]# chmod +x test.sh
[root@svr5 ~]# ./test.sh


四：
1 案例1：字符串截取及切割
1.1 问题

使用Shell完成各种Linux运维任务时，一旦涉及到判断、条件测试等相关操作时，往往需要对相关的命令输出进行过滤，提取出符合要求的字符串。
本案例要求熟悉字符串的常见处理操作，完成以下任务练习：
参考PPT示范操作，完成子串截取、替换等操作
根据课上的批量改名脚本，编写改进版renfilex.sh：能够批量修改当前目录下所有文件的扩展名，修改前/后的扩展名通过位置参数$1、$2提供
1.2 方案

子串截取的三种用法：
${变量名:起始位置:长度}
expr substr "$变量名" 起始位置 长度
echo $变量名 | cut -b 起始位置-结束位置
子串替换的两种用法：
只替换第一个匹配结果：${变量名/old/new}
替换全部匹配结果：${变量名//old/new}
字符串掐头去尾：
从左向右，最短匹配删除：${变量名#*关键词}
从左向右，最长匹配删除：${变量名##*关键词}
从右向左，最短匹配删除：${变量名%关键词*}
从右向左，最长匹配删除：${变量名%%关键词*}
1.3 步骤

实现此案例需要按照如下步骤进行。
步骤一：字符串的截取

1）方法一，使用 ${}表达式
格式：${变量名:起始位置:长度}
使用${}方式截取字符串时，起始位置是从0开始的。
定义一个变量phone，并确认其字符串长度：
[root@svr5 ~]# phone="13788768897"
[root@svr5 ~]# echo ${#phone}
11                                         //包括11个字符
使用${}截取时，起始位置可以省略，省略时从第一个字符开始截。比如，以下操作都可以从左侧开始截取前6个字符：
[root@svr5 ~]# echo ${phone:0:6}
137887
或者
[root@svr5 ~]# echo ${phone::6}
137887
因此，如果从起始位置1开始截取6个字符，那就变成这个样子了：
[root@svr5 ~]# echo ${phone:1:6}
378876
2）方法二，使用 expr substr
格式：expr substr "$变量名" 起始位置 长度
还以前面的phone变量为例，确认原始值：
[root@svr5 ~]# echo $phone
13788768897
使用expr substr截取字符串时，起始编号从1开始，这个要注意与${}相区分。
从左侧截取phone变量的前6个字符：
[root@svr5 ~]# expr substr "$phone" 1 6
137887
从左侧截取phone变量，从第9个字符开始，截取3个字符：
[root@svr5 ~]# expr substr "$phone" 9 3
897
3）方式三，使用cut分割工具
格式：echo $变量名 | cut -b 起始位置-结束位置
选项 -b 表示按字节截取字符，其中起始位置、结束位置都可以省略。当省略起始位置时，视为从第1个字符开始（编号也是从1开始，与expr类似），当省略结束位置时，视为截取到最后。
还以前面的Phone变量为例，确认原始值：
[root@svr5 ~]# echo $phone
13788768897
从左侧截取前6个字符，可执行以下操作：
[root@svr5 ~]# echo $phone | cut -b 1-6
137887
从第8个字符截取到末尾：
[root@svr5 ~]# echo $phone | cut -b 8-
8897
只截取单个字符，比如第9个字符：
[root@svr5 ~]# echo $phone | cut -b 9
8
截取不连续的字符，比如第3、5、8个字符：
[root@svr5 ~]# echo $phone | cut -b 3,5,8
788
4）一个随机密码的案例
版本1：
[root@svr5 ~]# vim rand.sh
#!/bin/bash
x=abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789
//所有密码的可能性是26+26+10=62（0-61是62个数字）
num=$[RANDOM%62]
pass=${x:num:1}
版本2：
[root@svr5 ~]# vim rand.sh
#!/bin/bash
x=abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789
//所有密码的可能性是26+26+10=62（0-61是62个数字）
pass=''
for i in {1..8}
do
num=$[RANDOM%62]
tmp=${x:num:1}
pass=${pass}$tmp
done
echo $pass

步骤三：字符串的匹配删除

以处理系统默认的账户信息为例，定义变量A：
[root@svr5 ~]# A=`head -1 /etc/passwd`
[root@svr5 ~]# echo $A
root:x:0:0:root:/root:/bin/bash
1）从左向右，最短匹配删除
格式：${变量名#*关键词}
删除从左侧第1个字符到最近的关键词“：”的部分，* 作通配符理解：
[root@svr5 ~]# echo ${A#*:}
x:0:0:root:/root:/bin/bash
2）从左向右，最长匹配删除
格式：${变量名##*关键词}
删除从左侧第1个字符到最远的关键词“:”的部分：
[root@svr5 ~]# echo $A                      //确认变量A的值
root:x:0:0:root:/root:/bin/bash
[root@svr5 ~]# echo ${A##*:}
/bin/bash
3）从右向左，最短匹配删除
格式：${变量名%关键词*}
删除从右侧最后1个字符到往左最近的关键词“:”的部分，* 做通配符理解：
[root@svr5 ~]# echo ${A%:*}
root:x:0:0:root:/root
4）从右向左，最长匹配删除
格式：${变量名%%关键词*}
删除从右侧最后1个字符到往左最远的关键词“:”的部分：
[root@svr5 ~]# echo ${A%%:*}
root

步骤四：编写renfilex.sh脚本

创建一个测试用的测试文件
[root@svr5 ~]# mkdir rendir
[root@svr5 ~]# cd rendir
[root@svr5 rendir]# touch {a,b,c,d,e,f,g,h,i}.doc
[root@svr5 rendir]# ls
a.doc  b.doc  c.doc  d.doc  e.doc  f.doc  g.doc  h.doc  i.doc
1）批量修改文件扩展名的脚本
脚本用途为：批量修改当前目录下的文件扩展名，将.doc改为.txt。
脚本内容参考如下：
[root@svr5 rendir]# vim renfile.sh
#!/bin/bash
for i in `ls *.doc`            #注意这里有反引号
do
    mv $i  ${i%.*}.txt
done
[root@svr5 ~]# chmod +x renfile.sh
测试脚本：
[root@svr5 rendir]# ./renfile.sh
[root@svr5 rendir]# ls
a.txt  b.txt  c.txt  d.txt  e.txt  f.txt  g.txt  h.txt  i.txt
2）改进版脚本(批量修改扩展名)
通过位置变量 $1、$2提供更灵活的脚本，改进的脚本编写参考如下：
[root@svr5 rendir]# vim ./renfile.sh
#!/bin/bash
#version:2
for i in `ls *.$1`
do
    mv $i  ${i%.*}.$2
done
3）验证、测试改进后的脚本
将 *.doc文件的扩展名改为.txt：
[root@svr5 rendir]# ./renfile.sh txt doc
将 *.doc文件的扩展名改为.mp4：
[root@svr5 rendir]# ./renfile.sh doc mp4

2 案例2：字符串初值的处理
2.1 问题

本案例要求编写一个脚本sumx.sh，求从1-x的和，相关要求如下：
从键盘读入x值
当用户未输入任何值时，默认按1计算
2.2 方案

通过${var:-word}判断变量是否存在，决定变量的初始值。
2.3 步骤

实现此案例需要按照如下步骤进行。
步骤一：认识字符串初值的最常见处理方法

1）只取值，${var:-word}
若变量var已存在且非Null，则返回 $var 的值；否则返回字串“word”，原变量var的值不受影响。
变量值已存在的情况：
[root@svr5 ~]# XX=11
[root@svr5 ~]# echo $XX              //查看原变量值
11
[root@svr5 ~]# echo ${XX:-123}      //因XX已存在，输出变量XX的值
11
变量值不存在的情况：
[root@svr5 ~]# echo ${YY:-123}      //因YY不存在，输出“123”
123
编写一个验证知识点的参考示例脚本如下：
[root@svr5 ~]# cat /root/test.sh
#!/bin/bash
read  -p   "请输入用户名:"   user
[ -z $user ] && exit                    //如果无用户名，则脚本退出
read  -p   "请输入密码:"   pass
pass=${pass:-123456}                    //如果用户没有输入密码，则默认密码为123456
useradd  $user
echo "$pass"  | passwd   --stdin   $user
步骤二：编写sumx.sh脚本，处理read输入的初值

用来从键盘读入一个正整数x，求从1到x的和；当用户未输入值（直接回车）时，为了避免执行出错，应为x赋初值1 。
1）脚本编写参考如下
[root@svr5 ~]# vim sumx.sh
#!/bin/bash
read -p "请输入一个正整数：" x
x=${x:-1}
i=1; SUM=0
while [ $i -le $x ]
do
    let SUM+=i
    let i++
done
echo "从1到$x的总和是：$SUM"
[root@svr5 ~]# chmod +x sumx.sh
2）验证、测试脚本执行效果：
[root@svr5 ~]# ./sumx.sh
请输入一个正整数：25                          //输入25，正常读入并计算、输出结果
从1到25的总和是：325
[root@svr5 ~]# ./sumx.sh
请输入一个正整数：70                         //输入70，正常读入并计算、输出结果
从1到70的总和是：2485
[root@svr5 ~]# ./sumx.sh
请输入一个正整数：                          //直接回车，设x=1后计算、输出结果
从1到1的总和是：1

3 案例3：expect预期交互
3.1 问题

本案例要求编写一个expect脚本，实现SSH登录的自动交互：
提前准备好目标主机，IP地址为192.168.4.5
执行脚本后自动登入，并且在目标主机建立测试文件 /tmp/mike.txt
3.2 方案

expect可以为交互式过程（比如FTP、SSH等登录过程）自动输送预先准备的文本或指令，而无需人工干预。触发的依据是预期会出现的特征提示文本。
储备知识（发送邮件的几种方式）：
[root@svr5 ~]# echo "test mail" | mail -s test root
[root@svr5 ~]# mail -s test root < /etc/passwd
[root@svr5 ~]# mail -s test root << EOF
test mail
hell world
EOF
3.3 步骤

实现此案例需要按照如下步骤进行。
步骤一：准备expect及SSH测试环境

1）安装expect工具
[root@svr5 ~]# yum  -y  install  expect                  //安装expect
.. ..
Installed:
  expect.x86_64 0:5.44.1.15-5.el6_4                                                            
Dependency Installed:
  tcl.x86_64 1:8.5.7-6.el6 
[root@svr5 ~]# which expect                              //确认expect路径
/usr/bin/expect
步骤二：编写脚本，实现免交互登录

1）任务需求及思路分析
在SSH登录过程中，如果是第一次连接到该目标主机，则首先会被要求接受密钥，然后才提示输入密码：
注意：不要照抄这里的IP地址，需要根据自己的实际IP填写！！！
[root@svr5 ~]# ssh root@192.168.4.5                              //连接目标主机
The authenticity of host '192.168.4.5 (192.168.4.5)' can't be established.
RSA key fingerprint is 58:a0:d6:00:c7:f1:34:5d:6c:6d:70:ce:e0:20:f8:f3.
Are you sure you want to continue connecting (yes/no)? yes          //接受密钥
Warning: Permanently added '192.168.4.5' (RSA) to the list of known hosts.
root@192.168.4.5's password:                                   //验证密码
Last login: Thu May  7 22:05:44 2015 from 192.168.4.5
[root@svr5 ~]$ exit                                             //返回客户端
logout
Connection to 192.168.4.5 closed.
当然，如果SSH登录并不是第一次，则接受密钥的环节就没有了，而是直接进入验证密码的过程：
注意：不要照抄这里的IP地址，需要根据自己的实际IP填写！！！
[root@svr5 ~]# ssh root@192.168.4.5                              //连接目标主机
root@192.168.4.5's password:                                   //验证密码
Last login: Mon May 11 12:02:39 2015 from 192.168.4.5
[root@svr5 ~]$ exit                                             //返回客户端
logout
Connection to 192.168.4.5 closed.
2）根据实现思路编写脚本文件
脚本内容参考如下版本1：
注意：不要照抄脚本里的IP地址与密码，需要根据自己的实际情况填写！！！
[root@svr5 ~]# vim  expect_ssh.sh 
#!/bin/bash
expect << EOF
spawn ssh 192.168.4.5                               #//创建交互式进程
expect "password:" { send "123456\r" }              #//自动发送密码
expect "#"          { send "touch /tmp.txt\r" }     #//发送命令
expect "#"          { send "exit\r" }
EOF
[root@svr5 ~]# chmod  +x  expect_ssh.sh 
通过循环批量操作，版本2：
注意：不要照抄脚本里的IP地址与密码，需要根据自己的实际情况填写！！！
[root@svr5 ~]# vim  expect_ssh.sh 
#!/bin/bash
for i in 10 11                                        #注意IP根据实际情况填写
do
expect << EOF
spawn ssh 192.168.4.$i                               #//创建交互式进程
expect "password:" { send "123456\r" }              #//自动发送密码
expect "#"          { send "touch /tmp.txt\r" }      #//发送命令
expect "#"          { send "exit\r" }
EOF
done
[root@svr5 ~]# chmod  +x  expect_ssh.sh 
注意事项：
expect脚本的最后一行默认不执行
如果不希望ssh时出现yes/no的提示，远程时使用如下选项:
# ssh -o StrictHostKeyChecking=no server0
4 案例4：使用正则表达式
4.1 问题

本案例要求熟悉正则表达式的编写，完成以下任务：
利用egrep工具练习正则表达式的基本用法
4.2 方案

表－1 基本正则列表

表－1 扩展正则列表

4.3 步骤

实现此案例需要按照如下步骤进行。
步骤一：正则表达式匹配练习

1）典型的应用场合：grep、egrep检索文本行
grep命令不带-E选项时，支持基本正则匹配模式。比如“word”关键词检索、“^word”匹配以word开头的行、“word$”匹配以word结尾的行……等等。
输出以“r”开头的用户记录：
[root@svr5 ~]# grep '^r' /etc/passwd
root:x:0:0:root:/root:/bin/bash
rpc:x:32:32:Portmapper RPC user:/:/sbin/nologin
rpcuser:x:29:29:RPC Service User:/var/lib/nfs:/sbin/nologin
输出以“localhost”结尾的行：
[root@svr5 ~]# grep 'localhost$' /etc/hosts
127.0.0.1               localhost.localdomain localhost
若希望在grep检索式同时组合多个条件，比如输出以“root”或者以“daemon”开头的行：
[root@svr5 ~]# grep '^root|^daemon' /etc/passwd          //搜索无结果
[root@svr5 ~]#
而若若使用grep -E或egrep命令，可支持扩展正则匹配模式，能够自动识别 |、{} 等扩展正则表达式中的特殊字符，用起来更加方便，比如：
[root@svr5 ~]# grep -E '^(root|daemon)' /etc/passwd
root:x:0:0:root:/root:/bin/bash
daemon:x:2:2:daemon:/sbin:/sbin/nologin
或者
[root@svr5 ~]# egrep '^(root|daemon)' /etc/passwd
root:x:0:0:root:/root:/bin/bash
daemon:x:2:2:daemon:/sbin:/sbin/nologin
使用grep -E 与 使用egrep命令完全等效，推荐使用后者，特别是涉及到复杂的正则表达式的时候。


2）grep、egrep命令的-q选项
选项 -q 表示 quiet（静默）的意思，结合此选项可以只做检索而并不输出，通常在脚本内用来识别查找的目标是否存在，通过返回状态 $? 来判断，这样可以忽略无关的文本信息，简化脚本输出。
比如，检查/etc/hosts文件内是否存在192.168.4.4的映射记录，如果存在则显示“YES”，否则输出“NO”，一般会执行：
[root@svr5 ~]# grep '^192.168.4.4' /etc/hosts && echo "YES" || echo "NO"
192.168.4.4     svr5.tarena.com svr5
YES
这样grep的输出信息和脚本判断后的提示混杂在一起，用户不易辨别，所以可以改成以下操作：
[root@svr5 ~]# grep -q '^192.168.4.4' /etc/hosts && echo "YES" || echo "NO"
YES
是不是清爽多了，从上述结果也可以看到，使用 -q 选项的效果与使用 &> /dev/null的效果类似。


3）基本元字符 ^、$ —— 匹配行首、行尾
输出注释的配置行（以#开头的行）：
[root@svr5 ~]# egrep '^#' /etc/inittab
统计本地用户中登录Shell为“/sbin/nologin”的用户个数：
提示：-m10仅在文件的前10行中过滤，后面的行不再过滤。
[root@svr5 ~]# egrep -m10 '/sbin/nologin$' /etc/passwd  //先确认匹配正确
bin:x:1:1:bin:/bin:/sbin/nologin
daemon:x:2:2:daemon:/sbin:/sbin/nologin
adm:x:3:4:adm:/var/adm:/sbin/nologin
lp:x:4:7:lp:/var/spool/lpd:/sbin/nologin
mail:x:8:12:mail:/var/spool/mail:/sbin/nologin
uucp:x:10:14:uucp:/var/spool/uucp:/sbin/nologin
operator:x:11:0:operator:/root:/sbin/nologin
games:x:12:100:games:/usr/games:/sbin/nologin
gopher:x:13:30:gopher:/var/gopher:/sbin/nologin
ftp:x:14:50:FTP User:/var/ftp:/sbin/nologin
[root@svr5 ~]# egrep -c '/sbin/nologin$' /etc/passwd
32                                      //结合 -c 选项输出匹配的行数
使用 -c 选项可输出匹配行数，这与通过管道再 wc -l的效果是相同的，但是写法更简便。比如，统计使用“/bin/bash”作为登录Shell的正常用户个数，可执行：
[root@svr5 ~]# egrep -c '/bin/bash$' /etc/passwd
26
或者
[root@svr5 ~]# egrep '/bin/bash$' /etc/passwd | wc -l
26


4）基本元字符 . —— 匹配任意单个字符

以/etc/rc.local文件为例，确认文本内容：
[root@svr5 ~]# cat /etc/rc.local
#!/bin/sh
#
# This script will be executed *after* all the other init scripts.
# You can put your own initialization stuff in here if you don't
# want to do the full Sys V style init stuff.
touch /var/lock/subsys/local
输出/etc/rc.local文件内至少包括一个字符（\n换行符除外）的行，即非空行：
[root@svr5 ~]# egrep '.' /etc/rc.local
#!/bin/sh
#
# This script will be executed *after* all the other init scripts.
# You can put your own initialization stuff in here if you don't
# want to do the full Sys V style init stuff.
touch /var/lock/subsys/local
输出/etc/rc.local文件内的空行（用 –v 选项将条件取反）：
[root@svr5 ~]# egrep -v '.' /etc/rc.local
[root@svr5 ~]#
上述取空行的操作与下列操作效果相同：
[root@svr5 ~]# egrep '^$' /etc/rc.local
[root@svr5 ~]#


5）基本元字符 +、?、* —— 目标出现的次数

还以/etc/rc.local文件为例：
[root@svr5 ~]# cat /etc/rc.local
#!/bin/sh
#
# This script will be executed *after* all the other init scripts.
# You can put your own initialization stuff in here if you don't
# want to do the full Sys V style init stuff.
touch /var/lock/subsys/local
输出包括 f、ff、ff、……的行，即“f”至少出现一次：
[root@svr5 ~]# egrep 'f+' /etc/rc.local
# This script will be executed *after* all the other init scripts.
# You can put your own initialization stuff in here if you don't
# want to do the full Sys V style init stuff.
输出包括init、initial的行，即末尾的“ial”最多出现一次（可能没有）：
[root@svr5 ~]# egrep 'init(ial)?' /etc/rc.local
# This script will be executed *after* all the other init scripts.
# You can put your own initialization stuff in here if you don't
# want to do the full Sys V style init stuff.
输出包括stu、stuf、stuff、stufff、……的行，即末尾的“f”可出现任意多次，也可以没有。重复目标只有一个字符时，可以不使用括号：
[root@svr5 ~]# egrep 'stuf*' /etc/rc.local
# You can put your own initialization stuff in here if you don't
# want to do the full Sys V style init stuff.
输出所有行，单独的“.*”可匹配任意行（包括空行）：
[root@svr5 ~]# egrep '.*' /etc/rc.local
#!/bin/sh
#
# This script will be executed *after* all the other init scripts.
# You can put your own initialization stuff in here if you don't
# want to do the full Sys V style init stuff.
touch /var/lock/subsys/local
输出/etc/passwd文件内“r”开头且以“nologin”结尾的用户记录，即中间可以是任意字符：
[root@svr5 ~]# egrep '^r.*nologin$' /etc/passwd
rpc:x:32:32:Portmapper RPC user:/:/sbin/nologin
rpcuser:x:29:29:RPC Service User:/var/lib/nfs:/sbin/nologin


6）元字符 {} —— 限定出现的次数范围
创建一个练习用的测试文件：
[root@svr5 ~]# vim brace.txt
ab def ghi abdr
dedef abab ghighi
abcab CD-ROM
TARENA IT GROUP
cdcd ababab
Hello abababab World
输出包括ababab的行，即“ab”连续出现3次：
[root@svr5 ~]# egrep '(ab){3}' brace.txt
cdcd ababab
Hello abababab World
输出包括abab、ababab、abababab的行，即“ab”连续出现2~4次：
[root@svr5 ~]# egrep '(ab){2,4}' brace.txt
dedef abab ghighi
cdcd ababab
Hello abababab World
输出包括ababab、abababab、……的行，即“ab”最少连续出现3次：
[root@svr5 ~]# egrep '(ab){3,}' brace.txt
cdcd ababab
Hello abababab World


7）元字符 [] —— 匹配范围内的单个字符
还以前面的测试文件bracet.txt为例：
[root@svr5 ~]# cat brace.txt
ab def ghi abdr
dedef abab ghighi
abcab CD-ROM
TARENA IT GROUP
cdcd ababab
Hello abababab World
输出包括abc、abd的行，即前两个字符为“ab”，第三个字符只要是c、d中的一个就符合条件：
[root@svr5 ~]# egrep 'ab[cd]' brace.txt
ab def ghi abdr
abcab CD-ROM
输出包括大写字母的行，使用[A-Z]匹配连续范围：
[root@svr5 ~]# egrep '[A-Z]' brace.txt
abcab CD-ROM
TARENA IT GROUP
Hello abababab World
过滤“非小写字母”的其他字符：
[root@svr5 ~]# egrep '[^a-z]' brace.txt


8）单词边界匹配


以文件/etc/rc.local为例：
[root@svr5 ~]# cat /etc/rc.local
#!/bin/sh
#
# This script will be executed *after* all the other init scripts.
# You can put your own initialization stuff in here if you don't
# want to do the full Sys V style init stuff.
touch /var/lock/subsys/local
输出包括单词“init”的行，文件中“initialization”不合要求：
[root@svr5 ~]# egrep '\binit\b' /etc/rc.local
# This script will be executed *after* all the other init scripts.
# want to do the full Sys V style init stuff.
或者：
[root@svr5 ~]# egrep '\<init\>' /etc/rc.local
# This script will be executed *after* all the other init scripts.
# want to do the full Sys V style init stuff.
输出包括以“ll”结尾的单词的行，使用 \> 匹配单词右边界：
[root@svr5 ~]# egrep 'll\>' /etc/rc.local
# This script will be executed *after* all the other init scripts.
# want to do the full Sys V style init stuff.
或者：
[root@svr5 ~]# egrep 'll\b' /etc/rc.local
# This script will be executed *after* all the other init scripts.
# want to do the full Sys V style init stuff.

9）多个条件的组合
通过dmesg启动日志查看蓝牙设备、网卡设备相关的信息：
[root@svr5 ~]# egrep -i 'eth|network|bluetooth' /var/log/dmesg
Initalizing network drop monitor service
Bluetooth: Core ver 2.10
Bluetooth: HCI device and connection manager initialized
Bluetooth: HCI socket layer initialized
Bluetooth: HCI USB driver ver 2.9
Intel(R) PRO/1000 Network Driver - version 7.3.21-k4-3-NAPI
e1000: eth0: e1000_probe: Intel(R) PRO/1000 Network Connection




Top
NSD SHELL DAY05

案例1：sed基本用法
案例2：使用sed修改系统配置
案例3：sed多行文本处理
案例4：sed综合脚本应用
1 案例1：sed基本用法
1.1 问题

本案例要求熟悉sed命令的p、d、s等常见操作，并结合正则表达式，完成以下任务：
删除文件中每行的第二个、最后一个字符
将文件中每行的第一个、第二个字符互换
删除文件中所有的数字
为文件中每个大写字母添加括号
1.2 方案

sed文本处理工具的用法：
用法1：前置命令 | sed  [选项]  '条件指令'
用法2：sed  [选项]  '条件指令'  文件.. ..
相关说明如下：
条件可以是行号或者/正则/
没有条件时，默认为所有条件
指令可以是增、删、改、查等指令
默认sed会将所有输出的内容都打印出来，可以使用-n屏蔽默认输出
选项中可以使用-r选项，让sed支持扩展正则
1.3 步骤

实现此案例需要按照如下步骤进行。
步骤一：认识sed工具的基本选项

sed命令的常用选项如下：
-n（屏蔽默认输出，默认sed会输出读取文档的全部内容）
-r（让sed支持扩展正则）
-i（sed直接修改源文件，默认sed只是通过内存临时修改文件，源文件无影响）
1）sed命令的 -n 选项
执行p打印等过滤操作时，希望看到的是符合条件的文本。但不使用任何选项时，默认会将原始文本一并输出，从而干扰过滤效果。比如，尝试用sed输出/etc/hosts的第1行：
[root@svr5 ~]# sed '1p' /etc/hosts
127.0.0.1   localhost localhost.localdomain localhost4 localhost4.localdomain4
127.0.0.1   localhost localhost.localdomain localhost4 localhost4.localdomain4
::1         localhost localhost.localdomain localhost6 localhost6.localdomain6
可以发现所有的行都被显示出来了（第1行重复2次）。—— 正确的用法应该添加 -n 选项，这样就可以只显示第1行了：
[root@svr5 ~]# sed -n '1p' /etc/hosts
127.0.0.1   localhost localhost.localdomain localhost4 localhost4.localdomain4
行号可以是连续的行号，如打印passwd第3到第6行账户的信息：
[root@svr5 ~]# sed  -n '3,6p' /etc/passwd
bin:x:1:1:bin:/bin:/sbin/nologin
daemon:x:2:2:daemon:/sbin:/sbin/nologin
adm:x:3:4:adm:/var/adm:/sbin/nologin
lp:x:4:7:lp:/var/spool/lpd:/sbin/nologin
2）sed命令的 -i 选项
正常情况下，sed命令所做的处理只是把操作结果（包括打印、删除等）输出到当前终端屏幕，而并不会对原始文件做任何更改：
[root@svr5 ~]# sed 'd' /etc/passwd                      //删除所有行
[root@svr5 ~]# cat /etc/passwd                          //查看原始文本，并未改动
若希望直接修改文件内容，应添加选项 -i 。
比如，直接删除test.txt（自行创建一个任意内容的文件）的第1~4行：
[root@svr5 ~]# sed -i '1,4d' test.txt            //删除操作
[root@svr5 ~]# cat test.txt                      //确认删除结果
下文中关于使用sed修改文件的示例中，为了避免大家在练习过程中因误操作导致系统故障，命令省略 –i 选项，不再逐一说明。需要时，大家可自行加上此选项。
3）多个指令可以使用分号隔离
用分号来隔离多个操作，比如：
[root@svr5 ~]# sed -n '1p;4p' /etc/passwd
root:x:0:0:root:/root:/bin/bash
adm:x:3:4:adm:/var/adm:/sbin/nologin
步骤二：认识sed工具的条件

# sed [选项] '条件指令' 文件.. ..
sed命令可以使用行号或正则做为条件匹配：
1）行号案例
打印第3行：
[root@svr5 ~]# sed -n '3p' /etc/passwd
打印第3到5行：
[root@svr5 ~]# sed -n '3,5p' /etc/passwd
打印第3和5行：
[root@svr5 ~]# sed -n '3p;5p' /etc/passwd
打印第3以及后面的10行：
[root@svr5 ~]# sed -n '3,+10p' /etc/passwd
打印奇数行：
[root@svr5 ~]# sed -n '1~2p' /etc/passwd
打印偶数行：
[root@svr5 ~]# sed -n '2~2p' /etc/passwd
2）正则案例
打印包含root的行：
[root@svr5 ~]# sed -n '/root/p' /etc/passwd
打印bash结尾的行：
[root@svr5 ~]# sed -n '/bash$/p' /etc/passwd
3）没有条件，则表示匹配所有行
[root@svr5 ~]# sed -n 'p' /etc/passwd
步骤三：sed工具的p、d、s操作指令案例集合

1）下面看看sed工具的p指令案例集锦（自己提前生成一个a.txt文件）
[root@svr5 ~]# sed  -n 'p' a.txt            //输出所有行，等同于cat a.txt
[root@svr5 ~]# sed  -n '4p' a.txt            //输出第4行
[root@svr5 ~]# sed  -n '4,7p' a.txt        //输出第4~7行
[root@svr5 ~]# sed  -n '4,+10p' a.txt        //输出第4行及其后的10行内容
[root@svr5 ~]# sed  -n '/^bin/p' a.txt        //输出以bin开头的行
[root@svr5 ~]# sed  -n '$=' a.txt            //输出文件的行数
2）下面看看sed工具的d指令案例集锦（自己提前生成一个a.txt文件）
[root@svr5 ~]# sed  '3,5d' a.txt             //删除第3~5行
[root@svr5 ~]# sed  '/xml/d' a.txt            //删除所有包含xml的行
[root@svr5 ~]# sed  '/xml/!d' a.txt         //删除不包含xml的行，!符号表示取反
[root@svr5 ~]# sed  '/^install/d' a.txt    //删除以install开头的行
[root@svr5 ~]# sed  '$d' a.txt                //删除文件的最后一行
[root@svr5 ~]# sed  '/^$/d' a.txt             //删除所有空行
3）sed命令的s替换基本功能（s/旧内容/新内容/选项）：
[root@svr5 ~]# vim  test.txt                //新建素材
2017 2011 2018
2017 2017 2024
2017 2017 2017
[root@svr5 ~]# sed 's/2017/xxxx/'           test.txt
[root@svr5 ~]# sed 's/2017/xxxx/g'          test.txt
[root@svr5 ~]# sed 's/2017/xxxx/2'          test.txt
[root@svr5 ~]# sed 's/2017//2'              test.txt
[root@svr5 ~]# sed -n 's/2017/xxxx/p'      test.txt
4）下面看看sed工具的s指令案例集锦（自己提前生成一个a.txt文件）
注意：替换操作的分隔“/”可改用其他字符，如#、&等，便于修改文件路径
[root@svr5 ~]# sed 's/xml/XML/'  a.txt        //将每行中第一个xml替换为XML
[root@svr5 ~]# sed 's/xml/XML/3' a.txt     //将每行中的第3个xml替换为XML
[root@svr5 ~]# sed 's/xml/XML/g' a.txt     //将所有的xml都替换为XML
[root@svr5 ~]# sed 's/xml//g'     a.txt     //将所有的xml都删除（替换为空串）
[root@svr5 ~]# sed 's#/bin/bash#/sbin/sh#' a.txt  //将/bin/bash替换为/sbin/sh
[root@svr5 ~]# sed '4,7s/^/#/'   a.txt         //将第4~7行注释掉（行首加#号）
[root@svr5 ~]# sed 's/^#an/an/'  a.txt         //解除以#an开头的行的注释（去除行首的#号）
步骤四：利用sed完成本例要求的任务

参考数据文件内容如下：
[root@svr5 ~]# cat nssw.txt
Hello the world
ni hao ma beijing
本小节的操作使用nssw.txt作为测试文件。
1）删除文件中每行的第二个、最后一个字符
分两次替换操作，第一次替换掉第2个字符，第二次替换掉最后一个字符：
[root@svr5 ~]# sed 's/.//2 ; s/.$//' nssw.txt 
2）将文件中每行的第一个、倒数第1个字符互换
每行文本拆分为“第1个字符”、“中间的所有字符”、“倒数第1个字符”三个部分，然后通过替换操作重排顺序为“3-2-1”：
[root@svr5 ~]# sed -r 's/^(.)(.*)(.)$/\3\2\1/' nssw.txt
3）删除文件中所有的数字
因原文件内没有数字，行首也没有空格，这里稍作做一点处理，生成一个新测试文件：
[root@svr5 ~]# sed 's/[0-9]//' nssw.txt
以nssw2.txt文件为例，删除所有数字、行首空格的操作如下：
[root@svr5 ~]# sed -r 's/[0-9]//g;s/^( )+//' nssw2.txt
4）为文件中每个大写字母添加括号
使用“（）”可实现保留功能，所以可参考下列操作解决：
[root@svr5 ~]# sed -r 's/([A-Z])/[\1]/g' nssw.txt
2 案例2：使用sed修改系统配置
2.1 问题

本案例要求熟悉课上的sed应用案例，并编写脚本anonftp.sh，实现以下功能：
通过yum安装vsftpd软件包
修改vsftpd服务配置，开启匿名上传
调整/var/ftp/pub目录权限，允许写入
启动vsftpd服务，并设置开机自运行
2.2 步骤

实现此案例需要按照如下步骤进行。
步骤一：编写anonftp.sh脚本，用来装配匿名FTP服务

1）任务需求及思路分析
vsftpd服务的安装、改目录权限、起服务等操作可以直接写在脚本中。
修改vsftpd.conf配置的工作可以使用sed命令，根据默认配置，只需要定位到以#anon开头的行，去掉开头的注释即可。
2）根据实现思路编写脚本文件
[root@svr5 ~]# vim anonftp.sh
#!/bin/bash
yum -y install vsftpd                             //安装vsftpd软件
cp /etc/vsftpd/vsftpd.conf{,.bak}                  //备份默认的配置文件
sed -i "s/^#anon/anon/" /etc/vsftpd/vsftpd.conf      //修改服务配置
chmod 777 /var/ftp/pub                              //调整目录权限
systemctl start vsftpd                              //启动服务
systemctl enable vsftpd                            //设为自动运行
[root@svr5 ~]# chmod +x anonftp.sh
[root@svr5 ~]# ./anonftp.sh
3 案例3：sed多行文本处理
3.1 问题

本案例要求使用sed工具来完成下列任务操作：
修改主机名配置文件
修改hosts文件，添加两条映射记录：192.168.4.5 与 svr5.tarena.com、svr5，还有119.75.217.56与www.baidu.com
3.2 方案

# sed [选项] '条件指令' 文件..
sed工具的多行文本处理操作：
i： 在指定的行之前插入文本
a：在指定的行之后追加文本
c：替换指定的行
3.3 步骤

基本语法格式案例：
注意：系统默认没有a.txt文件，需要自己创建一个测试文件！！！
[root@svr5 ~]# sed  '2a XX'   a.txt            //在第二行后面，追加XX
[root@svr5 ~]# sed  '2i XX'   a.txt            //在第二行前面，插入XX
[root@svr5 ~]# sed  '2c XX'   a.txt            //将第二行替换为XX
实现此案例需要按照如下步骤进行。
步骤一：修改主机名配置文件

1）确认修改前的配置
[root@svr5 ~]# cat /etc/hostname
svr5.tarena.com
2）使用sed修改主机名配置所在行的内容（c整行替换）
[root@svr5 ~]# sed  '1c mysvr.tarena.com' /etc/hostname 
步骤二：修改hosts文件，添加新的记录

1）确认修改前的配置
[root@svr5 ~]# cat /etc/hosts
127.0.0.1   localhost localhost.localdomain localhost4 localhost4.localdomain4
::1         localhost localhost.localdomain localhost6 localhost6.localdomain6
2）使用sed修改hosts文件，添加两行新纪录（a追加）
[root@svr5 ~]# sed  -i  '$a 192.168.4.5  svr5.tarena.com svr5'  /etc/hosts
127.0.0.1   localhost localhost.localdomain localhost4 localhost4.localdomain4
::1         localhost localhost.localdomain localhost6 localhost6.localdomain6
192.168.4.5  svr5.tarena.com svr5
4 案例4：sed综合脚本应用
4.1 问题

本案例要求编写脚本getupwd.sh，实现以下需求：
找到使用bash作登录Shell的本地用户
列出这些用户的shadow密码记录
按每行“用户名 --> 密码记录”保存到getupwd.log，如图-1所示

图－1
4.2 方案

基本思路如下：
先用sed工具取出登录Shell为/bin/bash的用户记录，保存为临时文件/tmp/urec.tmp，并计算记录数量
再结合while循环遍历取得的账号记录，逐行进行处理
针对每一行用户记录，采用掐头去尾的方式获得用户名、密码字串
按照指定格式追加到/tmp/getuupwd.log文件
结束循环后删除临时文件，报告分析结果
4.3 步骤

实现此案例需要按照如下步骤进行。
步骤一：编写getupwd.sh脚本

[root@svr5 ~]# vim ./getupwd.sh  
#/bin/bash
A=$(sed -n '/bash$/s/:.*//p' /etc/passwd)             ## 提取符合条件的账号记录
for i in  $A                                         ##遍历账号记录
do
    pass1=$(grep $i /etc/shadow)
    pass2=${pass1#*:}
    pass=${pass2%%:*}
    echo  "$i   --> $pass"
done
[root@svr5 ~]# chmod +x ./getupwd.sh 
步骤二：测试、验证执行结果

[root@svr5 ~]# ./getupwd.sh     
用户分析完毕，请查阅文件 /tmp/getupwd.log
[root@svr5 ~]# less /tmp/getupwd.log 
root --> $6$IWgMYmRACwdbfwBo$dr8Yn983nswiJVw0dTMjzbDvSLeCd1GMYjbvsDiFEkL8jnXOLcocBQypOCr4C6BRxNowIxjh6U2qeFU0u1LST/
zengye --> $6$Qb37LOdzRl5995PI$L0zTOgnhGz8ihWkW81J.5XhPp/l7x2./Me2ag0S8tRndCBL9nIjHIKkUKulHxJ6TXyHYmffbVgUT6pbSwf8O71
clamav --> !!
mysql --> !!
abc --> !!
.. ..
从上述参考脚本可以发现，使用sed来实现字段提取会比较复杂。下一章课程将会学到awk命令，届时可以通过更简单的方法来改进此脚本内容。
总结知识点：
#sed [选项] '条件指令' 文件
选项:
-n 屏蔽默认输出
-r 支持扩展正则
-i 修改源文件
条件：
行号 4 4,5 4~2 4,+10
/正则/
指令：
p 打印
d 删除
s 替换s/旧/新/g
a 追加
i 插入
c 替换行

Top
NSD SHELL DAY06

案例1：使用awk提取文本
案例2：awk处理条件
案例3：awk综合脚本应用
案例4：awk流程控制
案例5：awk扩展应用
1 案例1：使用awk提取文本
1.1 问题

本案例要求使用awk工具完成下列过滤任务：
练习awk工具的基本用法
提取本机的网卡流量、根分区剩余容量、获取SSH远程失败的IP地址
格式化输出/etc/passwd文件中的用户名、UID、宿主目录信息
1.2 步骤

实现此案例需要按照如下步骤进行。
步骤一：awk文本过滤的基本用法

1）基本操作方法
格式：awk [选项] '[条件]{指令}' 文件
其中，print 是最常用的编辑指令；若有多条编辑指令，可用分号分隔。
Awk过滤数据时支持仅打印某一列，如第2列、第5列等。
处理文本时，若未指定分隔符，则默认将空格、制表符等作为分隔符。
直接过滤文件内容：
[root@svr5 ~]# cat test.txt 
hello the world
welcome to beijing
[root@svr5 ~]# awk '{print $1,$3}' test.txt        //打印文档第1列和第3列
hello world
welcome beijing
结合管道过滤命令输出：
[root@svr5 ~]# df -h | awk '{print $4}'        //打印磁盘的剩余空间
2）选项 -F 可指定分隔符
输出passwd文件中以分号分隔的第1、7个字段，显示的不同字段之间以逗号隔开，操作如下：
[root@svr5 ~]# awk -F: '{print $1,$7}' /etc/passwd
root /bin/bash
bin /sbin/nologin
daemon /sbin/nologin
adm /sbin/nologin
lp /sbin/nologin
… …
awk还识别多种单个的字符，比如以“:”或“/”分隔，输出第1、10个字段：
[root@svr5 ~]# awk -F [:/] '{print $1,$10}' /etc/passwd
root bash
bin nologin
daemon nologin
adm sbin
… …
awk常用内置变量：
$0 文本当前行的全部内容
$1	文本的第1列
$2	文件的第2列
$3	文件的第3列，依此类推
NR	文件当前行的行号
NF	文件当前行的列数（有几列）
输出每次处理行的行号，以及当前行以“:”分隔的字段个数（有几列）：
[root@svr5 ~]# awk -F: '{print NR,NF}' passwd.txt
1 7
2 7
3 7
.. ..
2）awk的print指令不仅可以打印变量，还可以打印常量
[root@svr5 ~]# awk -F: '{print $1,"的解释器:",$7}' /etc/passwd
root 的解释器: /bin/bash
bin 的解释器: /sbin/nologin
… …
步骤二：利用awk提取本机的网络流量、根分区剩余容量、获取远程失败的IP地址

1）提取IP地址
分步实现的思路及操作参考如下——
通过ifconfig eth0查看网卡信息，其中包括网卡流量：
[root@svr5 ~]# ifconfig eth0
eth0: flags=4163<UP,BROADCAST,RUNNING,MULTICAST>  mtu 1500
        inet 192.168.4.21  netmask 255.255.255.0  broadcast 192.168.4.255
        inet6 fe80::fa64:c143:ad6a:5159  prefixlen 64  scopeid 0x20<link>
        ether 52:54:00:b3:11:11  txqueuelen 1000  (Ethernet)
        RX packets 313982  bytes 319665556 (304.8 MiB)
        RX errors 0  dropped 0  overruns 0  frame 0
        TX packets 51809  bytes 40788621 (38.8 MiB)
        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0
RX为接收的数据量，TX为发送的数据量。packets以数据包的数量为单位，bytes以字节为单位：
[root@svr5 ~]# ifconfig eth0 | awk '/RX p/{print $5}'    //过滤接收数据的流量
319663094
[root@svr5 ~]# ifconfig eth0 | awk '/TX p/{print $5}'     //过滤发送数据的流量
40791683
2）提取根分区剩余容量
分步实现的思路及操作参考如下——
通过df命令查看根分区的使用情况，其中包括剩余容量：
[root@svr5 ~]# df -h /
文件系统             容量     已用     可用     已用%     挂载点
/dev/sda2         19G         7.2G     11G         40%         /
输出上述结果中最后一行的第4列：
[root@svr5 ~]# df -h / | tail -1 | awk '{print $6}'
11G
或者直接在awk中使用正则：
[root@svr5 ~]# df -h | awk '/\/$/{print $4}'
11G
3）根据/var/log/secure日志文件，过滤远程连接密码失败的IP地址
[root@svr5 ~]# awk '/Failed/{print $11}' /var/log/secure
192.168.2.254
192.168.2.100
... ...
步骤三：格式化输出/etc/passwd文件

1）awk处理的时机
awk会逐行处理文本，支持在处理第一行之前做一些准备工作，以及在处理完最后一行之后做一些总结性质的工作。在命令格式上分别体现如下：
awk  [选项]  '[条件]{指令}'  文件
awk  [选项]  ' BEGIN{指令} {指令} END{指令}'  文件
BEGIN{ }	行前处理，读取文件内容前执行，指令执行1次
{ }	逐行处理，读取文件过程中执行，指令执行n次
END{ }	行后处理，读取文件结束后执行，指令执行1次
只做预处理的时候，可以没有操作文件，比如：
[root@svr5 ~]# awk 'BEGIN{A=24;print A*2}'
[root@svr5 ~]# awk 'BEGIN{print x+1}'           #x可以不定义，直接用，默认值位0
[root@svr5 ~]# awk 'BEGIN{print 3.2+3.5}'
举个例子（统计系统中使用bash作为登录Shell的用户总个数）：
a.预处理时赋值变量x=0
b.然后逐行读入/etc/passwd文件，如果发现登录Shell是/bin/bash则x加1
c.全部处理完毕后，输出x的值即可。相关操作及结果如下：
[root@svr5 ~]# awk 'BEGIN{x=0}/bash$/{x++} END{print x}' /etc/passwd
29
2）格式化输出/etc/passwd文件
要求: 格式化输出passwd文件内容时，要求第一行为列表标题，中间打印用户的名称、UID、家目录信息，最后一行提示一共已处理文本的总行数，如图-1所示。

图-1
3）根据实现思路编写、验证awk过滤语句
输出信息时，可以使用“\t”显示Tab制表位：
[root@svr5 ~]# awk -F: 'BEGIN{print "User\tUID\tHome"} \
                                {print $1 "\t"  $3  "\t"  $6}     \
                             END{print "Total",NR,"lines."}' /etc/passwd
User    UID     Home
root    0       /root
bin     1       /bin
daemon  2       /sbin
adm     3       /var/adm
lp      4       /var/spool/lpd
sync    5       /sbin
.. ..
Total 67 lines.
2 案例2：awk处理条件
2.1 问题

本案例要求使用awk工具完成下列过滤任务，注意awk处理条件的设置：
列出UID间于1~1000的用户详细信息
输出/etc/hosts文件内以127或192开头的记录
列出100以内整数中7的倍数或是含7的数
2.2 步骤

实现此案例需要按照如下步骤进行。
步骤一：认识awk处理条件的设置

1）使用正则设置条件
输出其中以bash结尾的完整记录：
[root@svr5 ~]# awk -F: '/bash$/{print}' /etc/passwd
root:x:0:0:root:/root:/bin/bash
输出包含root的行数据：
[root@svr5 ~]# awk -F: '/root/' /etc/passwd
输出root或adm账户的用户名和UID信息：
[root@svr5 ~]# awk -F: '/^(root|adm)/{print $1,$3}' /etc/passwd
root 0
adm 3
输出账户名称包含root的基本信息（第1列包含root）：
[root@svr5 ~]# awk -F: '$1~/root/' /etc/passwd
输出其中登录Shell不以nologin结尾（对第7个字段做!~反向匹配）的用户名、登录Shell信息：
[root@svr5 ~]# awk -F: '$7!~/nologin$/{print $1,$7}' /etc/passwd
root /bin/bash
sync /bin/sync
shutdown /sbin/shutdown
2）使用数值/字符串比较设置条件
比较符号：==(等于) !=（不等于） >（大于）
>=（大于等于） <（小于） <=（小于等于）
输出第3行（行号NR等于3）的用户记录：
[root@svr5 ~]# awk -F: 'NR==3{print}' /etc/passwd
输出账户UID大于等于1000的账户名称和UID信息：
[root@svr5 ~]# awk -F: '$3>=1000{print $1,$3}' /etc/passwd
tom 1000
jerry 1001
输出账户UID小于10的账户名称和UID信息：
[root@svr5 ~]# awk -F: '$3<10{print $1,$3}' /etc/passwd
root 0
bin 1
daemon 2
adm 3
lp 4
sync 5
shutdown 6
halt 7
mail 8
输出用户名为“root”的行：
[root@svr5 ~]# awk -F: '$1=="root"' /etc/passwd
root:x:0:0:root:/root:/bin/bash
3）逻辑测试条件
输出账户UID大于10并且小于20的账户信息：
[root@svr5 ~]# awk -F: '$3>10 && $3<20' /etc/passwd
operator:x:11:0:operator:/root:/sbin/nologin
games:x:12:100:games:/usr/games:/sbin/nologin
ftp:x:14:50:FTP User:/var/ftp:/sbin/nologin
输出账户UID大于1000或者账户UID小于10的账户信息：
[root@svr5 ~]# awk -F: '$3>1000 || $3<10' /etc/passwd
root:x:0:0:root:/root:/bin/bash
bin:x:1:1:bin:/bin:/sbin/nologin
daemon:x:2:2:daemon:/sbin:/sbin/nologin
adm:x:3:4:adm:/var/adm:/sbin/nologin
lp:x:4:7:lp:/var/spool/lpd:/sbin/nologin
sync:x:5:0:sync:/sbin:/bin/sync
shutdown:x:6:0:shutdown:/sbin:/sbin/shutdown
halt:x:7:0:halt:/sbin:/sbin/halt
mail:x:8:12:mail:/var/spool/mail:/sbin/nologin
varnish:x:1001:1001::/home/varnish:/sbin/nologin
nginx:x:1002:1002::/home/nginx:/sbin/nologin
4）数学运算
[root@svr5 ~]# awk 'BEGIN{x++;print x}'
1
[root@svr5 ~]# awk 'BEGIN{x=8;print x+=2}'
10
[root@svr5 ~]# awk 'BEGIN{x=8;x--;print x}'
7
[root@svr5 ~]# awk 'BEGIN{print 2+3}'
5
[root@svr5 ~]# awk 'BEGIN{print 2*3}'
6
[root@svr5 ~]# awk 'BEGIN{print 2*3}'
6
[root@svr5 ~]# awk 'BEGIN{ print 23%8}'
7
[root@svr5 ~]# seq  200 | awk  '$1%3==0'       //找200以内3的倍数
… …
步骤二：完成任务要求的awk过滤操作

1）列出UID间于1~1000的用户详细信息：
[root@svr5 ~]# awk -F: '$3>=1 && $3<=1000' /etc/passwd
2）输出/etc/hosts映射文件内以127或者192开头的记录：
[root@svr5 ~]# awk  '/^(127|192)/' /etc/hosts
127.0.0.1   localhost localhost.localdomain localhost4 localhost4.localdomain4
192.168.4.5  svr5.tarena.com svr5
3）列出100以内整数中7的倍数或是含7的数：
[root@svr5 ~]# seq 100 | awk '$1%7==0||$1~/7/'
7
14
17
21
27
28
35
37
42
47
.. ..
3 案例3：awk综合脚本应用
3.1 问题

本案例要求编写脚本，实现以下需求：
找到使用bash作登录Shell的本地用户
列出这些用户的shadow密码记录，如图-2所示

图－2
3.2 步骤

实现此案例需要按照如下步骤进行。
步骤一：任务需求及思路分析

编写脚本的任务要求如下：
分析出使用bash作登录Shell的本地用户
列出这些用户的shadow密码记录
按每行“用户名 -- 密码记录”保存结果
步骤二：根据实现思路编写脚本

[root@svr5 ~]# cat getupwd-awk.sh
#/bin/bash
A=$(awk -F:  '/bash$/{print $1}' /etc/passwd)        ## 提取符合条件的账号记录
for i in $A
do
        grep $i /etc/shadow | awk -F: '{print $1,"-->",$2}'                
done
步骤三：验证、测试脚本

[root@svr5 ~]# ./getupwd-awk.sh      
root --> $6$IWgMYmRACwdbfwBo$dr8Yn983nswiJVw0dTMjzbDvSLeCd1GMYjbvsDiFEkL8jnXOLcocBQypOCr4C6BRxNowIxjh6U2qeFU0u1LST/
zengye --> $6$Qb37LOdzRl5995PI$L0zTOgnhGz8ihWkW81J.5XhPp/l7x2./Me2ag0S8tRndCBL9nIjHIKkUKulHxJ6TXyHYmffbVgUT6pbSwf8O71
clamav --> !!
mysql --> !!
.. ..
4 案例4：awk流程控制
4.1 问题

本案例要求了解awk的流程控制操作，可自行设置awk语句来有验证以下操作：
if分支结构（单分支、双分支、多分支）
练习awk数组的使用
4.2 步骤

实现此案例需要按照如下步骤进行。
步骤一：awk过滤中的if分支结构

1）单分支
统计/etc/passwd文件中UID小于或等于1000的用户个数：
[root@svr5 ~]# awk -F: '{if($3<=1000){i++}}END{print i}' /etc/passwd
39
统计/etc/passwd文件中UID大于1000的用户个数：
[root@svr5 ~]# awk -F: '{if($3>1000){i++}}END{print i}' /etc/passwd
8
统计/etc/passwd文件中登录Shell是“/bin/bash”的用户个数：
[root@svr5 ~]# awk -F: '{if($7~/bash$/){i++}}END{print i}'  /etc/passwd
29
2）双分支
分别统计/etc/passwd文件中UID小于或等于1000、UID大于1000的用户个数：
[root@svr5 ~]# awk -F: '{if($3<=1000){i++}else{j++}}END{print i,j}' /etc/passwd
39 8
分别统计/etc/passwd文件中登录Shell是“/bin/bash”、 登录Shell不是“/bin/bash”的用户个数：
[root@svr5 ~]# awk -F: '{if($7~/bash$/){i++}else{j++}} END{print i,j}' /etc/passwd
29 38
步骤二：awk数组

1）数组的语法格式
数组是一个可以存储多个值的变量，具体使用的格式如下：
定义数组的格式：数组名[下标]=元素值
调用数组的格式：数组名[下标]
遍历数组的用法：for(变量 in 数组名){print 数组名[变量]}。
[root@svr5 ~]# awk 'BEGIN{a[0]=11;a[1]=88;print a[1],a[0]}'
88 11
[root@svr5 ~]# awk 'BEGIN{a++;print a}'
1
[root@svr5 ~]# awk 'BEGIN{a0++;print a0}'
1
[root@svr5 ~]# awk 'BEGIN{a[0]++;print a[0]}'
1
[root@svr5 ~]# awk 'BEGIN{a[0]=0;a[1]=11;a[2]=22; for(i in a){print i,a[i]}}'
0 0
1 11
2 22
注意，awk数组的下标除了可以使用数字，也可以使用字符串，字符串需要使用双引号：
[root@svr5 ~]# awk 'BEGIN{a["hehe"]=11;print a["hehe"]}'
11
5 案例5：awk扩展应用
5.1 问题

本案例要求使用awk工具完成下列两个任务：
分析Web日志的访问量排名，要求获得客户机的地址、访问次数，并且按照访问次数排名
5.2 方案

1）awk统计Web访问排名
在分析Web日志文件时，每条访问记录的第一列就是客户机的IP地址，其中会有很多重复的IP地址。因此只用awk提取出这一列是不够的，还需要统计重复记录的数量并且进行排序。
通过awk提取信息时，利用IP地址作为数组下标，每遇到一个重复值就将此数组元素递增1，最终就获得了这个IP地址出现的次数。
针对文本排序输出可以采用sort命令，相关的常见选项为-r、-n、-k。其中-n表示按数字顺序升序排列，而-r表示反序，-k可以指定按第几个字段来排序。
5.3 步骤

实现此案例需要按照如下步骤进行。
步骤一：统计Web访问量排名

分步测试、验证效果如下所述。
1）提取IP地址及访问量
[root@svr5 ~]# awk '{ip[$1]++} \
>  END{for(i in ip) {print ip[i],i }}' /var/log/httpd/access_log
4  127.0.0.1
17 192.168.4.5
13 192.168.4.110
.. ..
2）对第1）步的结果根据访问量排名
[root@svr5 ~]# awk  '{ip[$1]++} END{for(i in ip) {print i,ip[i]}}' /var/log/httpd/access_log | sort -nr
17 192.168.4.5
13 192.168.4.110
4 127.0.0.1
.. ..
























